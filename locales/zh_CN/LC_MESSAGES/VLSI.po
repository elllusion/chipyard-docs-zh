# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Berkeley Architecture Research
# This file is distributed under the same license as the Chipyard package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Chipyard \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-28 13:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../VLSI/Advanced-Usage.rst:4
msgid "Advanced Usage"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:7
msgid "Alternative RTL Flows"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:8
msgid ""
"The Make-based build system provided supports using Hammer without using "
"RTL generated by Chipyard. To push a custom Verilog module through, one "
"only needs to append the following environment variables to the ``make "
"buildfile`` command (or edit them directly in the Makefile)."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:15
msgid ""
"``CUSTOM_VLOG`` breaks the dependency on the rest of the Chipyard "
"infrastructure and does not start any Chisel/FIRRTL elaboration. "
"``VLSI_TOP`` selects the top module from your custom Verilog files."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:18
msgid "Under the Hood"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:19
msgid ""
"To uncover what is happening under the hood, here are the commands that "
"are executed:"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:21
msgid "For ``make syn``:"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:27
msgid ""
"``example-vlsi`` is the entry script as explained before, ``-e`` provides"
" the environment yml, ``-p`` points to configuration yml/jsons, "
"``--obj_dir`` speficies the destination directory,  and ``syn`` is the "
"action."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:29
msgid "For ``make par``:"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:36
msgid ""
"A ``syn-to-par`` action translates the synthesis output configuration "
"into an input configuration given by ``-o``. Then, this is passed to the "
"``par`` action."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:38
msgid ""
"For more information about all the options that can be passed to the "
"Hammer command-line driver, please see the Hammer documentation."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:41
msgid "Manual Step Execution & Dependency Tracking"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:42
msgid ""
"It is invariably necessary to debug certain steps of the flow, e.g. if "
"the power strap settings need to be updated. The underlying Hammer "
"commands support options such as ``--to_step``, ``--from_step``, and "
"``--only_step``. These allow you to control which steps of a particular "
"action are executed."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:44
msgid ""
"Make's dependency tracking can sometimes result in re-starting the entire"
" flow when the user only wants to re-run a certain action. Hammer's build"
" system has \"redo\" targets such as ``redo-syn`` and ``redo-par`` to run"
" certain actions without typing out the entire Hammer command."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:46
msgid ""
"Say you need to update some power straps settings in ``example.yml`` and "
"want to try out the new settings:"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:53
msgid "RTL/Gate-level Simulation, Power Estimation"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:54
msgid ""
"With the Synopsys plugin, RTL and gate-level simulation is supported "
"using VCS at the chip-level. Also, post-par power estimation with Voltus "
"in the Cadence plugin is also supported. While the provided example does "
"not implement any simulation, some Make targets are provided in the "
"``vlsi/`` directory. Here is a brief description:"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:56
msgid "``sim-rtl``: RTL-level simulation"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:58
msgid "``sim-rtl-debug``: Also write a VPD waveform"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:60
msgid "``sim-syn``: Post-synthesis gate-level simulation"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:62
msgid "``sim-syn-debug``: Also write a VPD waveform"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:63
msgid "``sim-syn-timing-debug``: Timing-annotated with VPD waveform"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:65
msgid "``sim-par``: Post-par gate-level simulation"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:67
msgid "``sim-par-debug``: Also write a VPD waveform"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:68
msgid "``sim-par-timing-debug``: Timing-annotated with VPD waveform"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:70
msgid "``power-par``: Post-par power estimation"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:72
msgid "Note: this will run ``sim-par`` first"
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:74
msgid ""
"``redo-`` can be appended to all above targets to break dependency "
"tracking, like described above."
msgstr ""

#: ../../VLSI/Advanced-Usage.rst:76
msgid ""
"The simulation configuration (e.g. binaries) can be edited for your "
"design. See the Makefile and refer to Hammer's documentation for how to "
"set up simulation parameters for your design."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:4
msgid "Using Hammer To Place and Route a Custom Block"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:6
msgid ""
"In order to use the Hammer VLSI flow, you need access to Hammer tools and"
" technology plugins. You can obtain these by emailing hammer-plugins-"
"access@lists.berkeley.edu with a request for which plugin(s) you would "
"like access to. Make sure your email includes your github ID and proof "
"(through affiliation or otherwise) that you have licensed access to "
"relevant tools."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:9
msgid "Initialize the Hammer Plug-ins"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:10 ../../VLSI/Tutorial.rst:63
msgid "In the Chipyard root, run:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:16
msgid ""
"This will pull the Hammer & CAD tool plugin submodules, assuming the "
"technology plugins are available on github. Currently only the asap7 "
"technology plugin is available on github. If you have additional private "
"technology plugins (this is a typical use-case for proprietry process "
"technologies with require NDAs and secure servers), you can clone them "
"directly into VLSI directory with the name ``hammer-<tech-plugin-"
"name>-plugin``. For example, for an imaginary process technology called "
"tsmintel3:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:28
msgid "Next, we define the Hammer environment into the shell:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:37
msgid ""
"Some VLSI EDA tools are supported only on RHEL-based operating systems. "
"We recommend using Chipyard on RHEL7 and above. However, many VLSI server"
" still have old operating systems such as RHEL6, which have software "
"packages older than the basic chipyard requirements. In order to build "
"Chipyard on RHEL6, you will likely need to use tool packages such as "
"devtoolset (for example, devtoolset-8) and/or build from source gcc, git,"
" gmake, make, dtc, cc, bison, libexpat and liby."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:40
msgid "Setting up the Hammer Configuration Files"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:42
msgid ""
"The first configuration file that needs to be set up is the Hammer "
"environment configuration file ``env.yml``. In this file you need to set "
"the paths to the EDA tools and license servers you will be using. You do "
"not have to fill all the fields in this configuration file, you only need"
" to fill in the paths for the tools that you will be using. If you are "
"working within a shared server farm environment with an LSF cluster setup"
" (for example, the Berkeley Wireless Research Center), please note the "
"additional possible environment configuration listed in the :ref:`VLSI"
"/Basic-Flow:Advanced Environment Setup` segment of this documentation "
"page."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:45
msgid ""
"Hammer relies on YAML-based configuration files. While these "
"configuration can be consolidated within a single files (as is the case "
"in the ASAP7 tutorial :ref:`tutorial` and the ``nangate45`` OpenRoad "
"example), the generally suggested way to work with an arbitrary process "
"technology or tools plugins would be to use three configuration files, "
"matching the three Hammer concerns - tools, tech, and design. The "
"``vlsi`` directory includes three such example configuration files "
"matching the three concerns: ``example-tools.yml``, ``example-tech.yml``,"
" and ``example-design.yml``."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:49
msgid ""
"The ``example-tools.yml`` file configures which EDA tools hammer will "
"use. This example file uses Cadence Innovus, Genus and Voltus, Synopsys "
"VCS, and Mentor Calibre (which are likely the tools you will use if "
"you're working in the Berkeley Wireless Research Center). Note that tool "
"versions are highly sensitive to the process-technology in-use. Hence, "
"tool versions that work with one process technology may not work with "
"another (for example, ASAP7 will not work with an Innovus version newer "
"than 18.1, while other proprietary process technologies will likely "
"require newer versions such as 19.1)."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:51
msgid ""
"The ``example-design.yml`` file contains basic build system information "
"(how many cores/threads to use, etc.), as well as configurations that are"
" specific to the design we are working on such as clock signal name and "
"frequency, power modes, floorplan, and additional constraints that we "
"will add later on."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:53
msgid ""
"Finally, the ``example-tech`` file is a template file for a process "
"technology plugin configuration. We will copy this file, and replace its "
"fields with the appropriate process technology details for the tech "
"plugin that we have access to. For example, for the ``asap7`` tech plugin"
" we will replace the <tech_name> field with \"asap7\", the Node size "
"\"N\" with \"7\", and the path to the process technology files "
"installation directory."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:55
msgid ""
"We recommend copying these example configuration files and customizing "
"them with a different name, so you can have different configuration files"
" for different process technologies and designs (e.g. create tech-"
"tsmintel3.yml from example-tech.yml)"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:59 ../../VLSI/Tutorial.rst:80
msgid "Building the Design"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:60
msgid ""
"After we have set the configuration files, we will now elaborate our "
"Chipyard Chisel design into Verilog, while also performing the required "
"transformations in order to make the Verilog VLSI-friendly. Additionally,"
" we will automatically generate another set of Hammer configuration files"
" matching to this design, which will be used in order to configure the "
"physical design tools. We will do so by calling ``make buildfile`` with "
"appropriate Chipyard configuration variables and Hammer configuration "
"files. As in the rest of the Chipyard flows, we specify our SoC "
"configuration using the ``CONFIG`` make variable. However, unlike the "
"rest of the Chipyard flows, in the case of physical design we might be "
"interested in working in a hierarchical fashion and therefore we would "
"like to work on a single module. Therefore, we can also specify a "
"``VLSI_TOP`` make variable with the same of a specific Verilog module "
"(which should also match the name of the equivalent Chisel module) which "
"we would like to work on. The makefile will automatically call tools such"
" as Barstools and the MacroCompiler (:ref:`Tools/Barstools:barstools`) in"
" order to make the generated Verilog more VLSI friendly. By default, the "
"MacroCompiler will attempt to map memories into the SRAM options within "
"the Hammer technology plugin. However, if you are working with a new "
"process technology and prefer to work with flip-flop arrays, you can "
"configure the MacroCompiler using the ``MACROCOMPILER_MODE`` make "
"variable. For example, if your technology plugin does not have an SRAM "
"compiler ready, you can use the ``MACROCOMPILER_MODE='--mode synflops'`` "
"option (Note that synthesizing a design with only flipflops is very slow "
"and will often may not meet constraints)."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:69
msgid ""
"We call the ``make buildfile`` command while also specifying the name of "
"the process technology we are working with (same ``tech_name`` for the "
"configuration files and plugin name) and the configuration files we "
"created. Note, in the ASAP7 tutorial ((:ref:`tutorial`)) these "
"configuration files are merged into a single file called ``example-"
"asap7.yml``."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:71
msgid ""
"Hence, if we want to monolithically place and route the entire SoC, the "
"relevant command would be"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:77 ../../VLSI/Basic-Flow.rst:100
msgid ""
"In a more typical scenario of working on a single module, for example the"
" Gemmini accelerator within the GemminiRocketConfig Chipyard SoC "
"configuration, the relevant command would be:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:84 ../../VLSI/Tutorial.rst:92
msgid "Running the VLSI Flow"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:86
msgid ""
"Running a basic VLSI flow using the Hammer default configurations is "
"fairly simple, and consists of simple ``make`` command with the "
"previously mentioned Make variables."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:89 ../../VLSI/Tutorial.rst:107
msgid "Synthesis"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:91
msgid ""
"In order to run synthesis, we run ``make syn`` with the matching Make "
"variables. Post-synthesis logs and collateral will be saved in ``build"
"/<config-name>/syn-rundir``. The raw QoR data (area, timing, gate counts,"
" etc.) will be found in ``build/<config-name>/syn-rundir/reports``."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:94
msgid ""
"Hence, if we want to monolithically synthesize the entire SoC, the "
"relevant command would be:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:107
msgid ""
"It is worth checking the final-qor.rpt report to make sure that the "
"synthesized design meets timing before moving to the place-and-route "
"step."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:110 ../../VLSI/Tutorial.rst:115
msgid "Place-and-Route"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:111
msgid ""
"In order to run place-and-route, we run ``make par`` with the matching "
"Make variables. Post-PnR logs and collateral will be saved in ``build"
"/<config-name>/par-rundir``. Specifically, the resulting GDSII file will "
"be in that directory with the suffix ``*.gds``. and timing reports can be"
" found in ``build/<config-name>/par-rundir/timingReports``. Place-and-"
"route is requires more design details in contrast to synthesis. For "
"example, place-and-route requires some basic floorplanning constraints. "
"The default ``example-design.yml`` configuration file template allows the"
" tool (specifically, the Cadence Innovus tool) to use it's automatic "
"floorplanning capability within the top level of the design "
"(``ChipTop``). However, if we choose to place-and-route a specific block "
"which is not the SoC top level, we need to change the top-level path name"
" to match the ``VLSI_TOP`` make parameter we are using."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:115
msgid ""
"Hence, if we want to monolitically place-and-route the entire SoC with "
"the default tech plug-in parameters for power-straps and corners, the "
"relevant command would be:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:121
msgid ""
"In a more typical scenario of working on a single module, for example the"
" Gemmini accelerator within the GemminiRocketConfig Chipyard SoC "
"configuration,"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:138
msgid "The relevant ``make`` command would then be:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:144
msgid ""
"Note that the width and height specification can vary widely between "
"different modulesi and level of the module hierarchy. Make sure to set "
"sane width and height values. Place-and-route generally requires more "
"fine-grained input specifications regarding power nets, clock nets, pin "
"assignments and floorplanning. While the template configuration files "
"provide defaults for automatic tool defaults, these will usually result "
"in very bad QoR, and therefore it is recommended to specify better-"
"informed floorplans, pin assignments and power nets. For more information"
" about cutomizing theses parameters, please refer to the :ref:`VLSI"
"/Basic-Flow:Customizing Your VLSI Flow in Hammer` sections or to the "
"Hammer documentation. Additionally, some Hammer process technology "
"plugins do not provide sufficient default values for requires settings "
"such as power nets and pin assignments (for example, ASAP7). In those "
"cases, these constraints will need to be specified manually in the top-"
"level configuration yml files, as is the case in the ``example-"
"asap7.yml`` configuration file."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:148
msgid ""
"Place-and-route tools are very sensitive to process technologes "
"(significantly more sensitive than synthesis tools), and different "
"process technologies may work only on specific tool versions. It is "
"recommended to check what is the appropriate tool version for the "
"specific process technology you are working with."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:151
msgid ""
"If you edit the yml configuration files in between synthesis and place-"
"and-route, the `make par` command will automatically re-run synthesis. If"
" you would like to avoid that and are confident that your configuration "
"file changes do not affect synthesis results, you may use the `make redo-"
"par` instead."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:156
msgid "Power Estimation"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:157
msgid ""
"Power estimation in Hammer can be performed in one of two stages: post-"
"synthesis (post-syn) or post-place-and-route (post-par). The most "
"accurate power estimation is post-par, and it includes finer grained "
"details of the places instances and wire lengths. Post-par power "
"estimation can be based on static average signal toggles rates (also "
"known as \"static power estimation\"), or based on simulation-extracted "
"signal toggle data (also known as \"dynamic power estimation\")."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:160
msgid ""
"In order to run post-par power estimation, make sure that a power "
"estimation tool (such as Cadence Voltus) has been defined in your "
"``example-tools.yml`` file. Make sure that the power estimation tool (for"
" example, Cadence Voltus) version matches the physical design tool (for "
"example, Cadence Innovus) version, otherwise you will encounter a "
"database mismatch error."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:162
msgid ""
"Simulation-exacted power estimation often requires a dedicated "
"testharness for the block under evalution (DUT). While the Hammer flow "
"supports such configurations (further details can be found in the Hammer "
"documentation), Chipyard's integrated flows support an automated full "
"digital SoC simulation-extracted post-par power estimation through the "
"integration of software RTL simulation flows with the Hammer VLSI flow. "
"As such, full digital SoC simulation-extracted power estimation can be "
"performed by specifying a simple binary executable with the associated "
"``make`` command."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:169
msgid ""
"The simulation-extracted power estimation flow implicitly uses Hammer's "
"gate-level simulation flow (in order to generate the ``saif`` activity "
"data file). This gate-level simulation flow can also be run independantly"
" from the power estimation flow using the ``make sim-par`` command."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:172
msgid ""
"The gate-level simulation flow (and there the simulation-extracted power-"
"estimation) is currently integrated only with the Synopsys VCS simulation"
" (Verilator does not support gate-level simulation. Support for Cadence "
"Incisive is work-in-progress)"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:176
msgid "Signoff"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:178
msgid ""
"During chip tapeout, you will need to perform sign-off check to make sure"
" the generated GDSII can be fabricated as intended. This is done using "
"dedicated signoff tools that perform design rule checking (DRC) and "
"layout versus schematic (LVS) verification. In most cases, placed-and-"
"routed designs will not pass DRC and LVS on first attempts due to nuanced"
" design rules and subtle/silent failures of the place-and-route tools. "
"Passing DRC and LVS will often requires adding manual placement "
"constraints to \"force\" the EDA tools into certain patterns. If you have"
" placed-and-routed a design with the goal of getting area and power "
"estimates, DRC and LVS are not strictly neccessary and the results will "
"likely be quite similar. If you are intending to tapeout and fabricate a "
"chip, DRC and LVS are mandatory and will likely requires multiple-"
"iterations of refining manual placement constraints. Having a large "
"number of DRC/LVS violations can have a significant impact on the runtime"
" of the place-and-route procedure (since the tools will try to fix each "
"of them several times). A large number of DRC/LVS violations may also be "
"an indication that the design is not necessarily realistic for this "
"particular process technology, which may have power/area implications."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:183
msgid ""
"Since signoff checks are required only for a complete chip tapeout, they "
"are currently not fully automated in Hammer, and often require some "
"additional manual inclusion of custom Makefiles associated with specific "
"process technologies. However, the general steps from running signoff "
"within Hammer (under the assumption of a fully automated tech plug-in) "
"are Make commands similar to the previous steps."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:185
msgid ""
"In order to run DRC, the relevant ``make`` command is ``make drc``. As in"
" the previous stages, the make command should be accompanied by the "
"relevant configuration Make variables:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:192
msgid ""
"DRC does not emit easily audited reports, as the rule names violated can "
"be quite esoteric. It is often more productive to rather use the scripts "
"generated by Hammer to open the DRC error database within the appropriate"
" tool. These generated scripts can be called from ``./build/<config-name"
">/drc-rundir/generated-scripts/view_drc``."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:195
msgid ""
"In order to run LVS, the relevant ``make`` command is ``make lvs``. As in"
" the previous stages, the make command should be accompanied by the "
"relevant configuration Make variables:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:201
msgid ""
"LVS does not emit easily audited reports, as the violations are often "
"cryptic when seen textually. As a result it is often more productive to "
"visually see the LVS issues using the generated scripts that enable "
"opening the LVS error database within the appropriate tool. These "
"generated scripts can be called from ``./build/<config-name>/lvs-rundir"
"/generated-scripts/view_lvs``."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:205
msgid "Customizing Your VLSI Flow in Hammer"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:208
msgid "Advanced Environment Setup"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:210
msgid ""
"If you have access to a shared LSF cluster and you would like Hammer to "
"submit it's compute-intensive jobs to the LSF cluster rather than your "
"login machine, you can add the following code segment to your ``env.yml``"
" file (completing the relevant values for the bsub binary path, the "
"number of CPUs requested, and the requested LSF queue):"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:229
msgid "Composing a Hierarchical Design"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:231
msgid ""
"For large designs, a monolithic VLSI flow may take the EDA tools a very "
"long time to process and optimize, to the extent that it may not be "
"feasable sometimes. Hammer supports a hierarchical physical design flow, "
"which decomposes the design into several specified sub-components and "
"runs the flow on each sub-components separetly. Hammer is then able to "
"assemble these blocks together into a top-level design. This hierarchical"
" approach speeds up the VLSI flow for large designs, especially designs "
"in which there may me multiple instantiations of the same sub-"
"components(since the sub-component can simply be replicated in the "
"layout). While hierarchical physical design can be performed in multiple "
"ways (top-down, bottom-up, abutment etc.), Hammer currently supports only"
" the bottom-up approach. The bottom-up approach traverses a tree "
"representing the hierarchy starting from the leaves and towards the "
"direction of the root (the \"top level\"), and runs the physical design "
"flow on each node of the hierarchy tree using the previously layed-out "
"children nodes. As nodes get closer to the root (or \"top level\") of the"
" hierarchy, largers sections of the design get layed-out."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:237
msgid ""
"The Hammer hierarchical flow relies on a manually-specified descrition of"
" the desired heirarchy tree. The specification of the heirarchy tree is "
"defined based on the instance names in the generated Verilog, which "
"sometime make this specification challenging due to inconsisent instance "
"names. Additionally, the specification of the heirarchy tree is "
"intertwined with the manual specification of a floorplan for the design."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:239
msgid ""
"For example, if we choose to specifiy the previously mentioned "
"``GemminiRocketConfig`` configuration in a hierarchical fashion in which "
"the Gemmini accelerator and the last-level cache are run separetly from "
"the top-level SoC, we would replace the floorplan example in ``example-"
"design.yml`` from the :ref:`VLSI/Basic-Flow:Place-and-Route` section with"
" the following specification:"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:305
msgid ""
"In this specification, ``vlsi.inputs.hierarchical.mode`` indicates the "
"manual specification of the heirarchy tree (which is the only mode "
"currently supported by Hammer), ``vlsi.inputs.hiearchical.top_module`` "
"sets the root of the hierarchical tree, "
"``vlsi.inputs.hierarchical.manual_modules`` enumerates the tree of "
"hierarchical modules, and "
"``vlsi.inputs.hierarchical.manual_placement_constraints`` enumerates the "
"floorplan for each module."
msgstr ""

#: ../../VLSI/Basic-Flow.rst:313
msgid "Customizing Generated Tcl Scripts"
msgstr ""

#: ../../VLSI/Basic-Flow.rst:314
msgid ""
"The ``example-vlsi`` python script is the Hammer entry script with "
"placeholders for hooks. Hooks are additional snippets of python and TCL "
"(via ``x.append()``) to extend the Hammer APIs. Hooks can be inserted "
"using the ``make_pre/post/replacement_hook`` methods as shown in the "
"``example-vlsi`` entry script example. In this particular example, a list"
" of hooks is paased in the ``get_extra_par_hooks`` function in the "
"``ExampleDriver`` class. Refer to the `Hammer documentation on hooks "
"<https://hammer-vlsi.readthedocs.io/en/latest/Hammer-Use/Hooks.html>`__ "
"for a detailed description of how these are injected into the VLSI flow."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:4
msgid "Building A Chip"
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:6
msgid ""
"In this section, we will discuss many of the ASIC-specific transforms and"
" methodologies within Chipyard. For the full documentation on how to use "
"the VLSI tool flow, see the `Hammer Documentation <https://hammer-"
"vlsi.readthedocs.io/>`__."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:10
msgid "Transforming the RTL"
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:12
msgid ""
"Building a chip requires specializing the generic verilog emitted by "
"FIRRTL to adhere to the constraints imposed by the technology used for "
"fabrication. This includes mapping Chisel memories to available "
"technology macros such as SRAMs, mapping the input and output of your "
"chip to connect to technology IO cells, see "
":ref:`Tools/Barstools:Barstools`. In addition to these required "
"transformations, it may also be beneficial to transform the RTL to make "
"it more amenable to hierarchical physical design easier. This often "
"includes modifying the logical hierarchy to match the physical hierarchy "
"through grouping components together or flattening components into a "
"single larger module."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:19
msgid "Modifying the logical hierarchy"
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:21
msgid ""
"Building a large or complex chip often requires using hierarchical design"
" to place and route sections of the chip separately. In addition, the "
"design as written in Chipyard may not have a hierarchy that matches the "
"physical hierarchy that would work best in the place and route tool. In "
"order to reorganize the design to have its logical hierarchy match its "
"physical hierarchy there are several FIRRTL transformations that can be "
"run. These include grouping, which pull several modules into a larger "
"one, and flattening, which dissolves a modules boundary leaving its "
"components in its containing module. These transformations can be applied"
" repeatedly to different parts of the design to arrange it as the "
"physical designer sees fit. More details on how to use these "
"transformations to reorganize the design hierarchy are forthcoming."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:30
msgid "Creating a floorplan"
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:32
msgid ""
"An ASIC floorplan is a specification that the place-and-route tools will "
"follow when placing instances in the design. This includes the top-level "
"chip dimensions, placement of SRAM macros, placement of custom (analog) "
"circuits, IO cell placement, bump or wirebond pad placement, blockages, "
"hierarchical boundaries, and pin placement."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:35
msgid ""
"Much of the design effort that goes into building a chip involves "
"developing optimal floorplans for the instance of the design that is "
"being manufactured. Often this is a highly manual and iterative process "
"which consumes much of the physical designer's time. This cost becomes "
"increasingly apparent as the parameterization space grows rapidly when "
"using tools like Chisel- cycle times are hampered by the human labor that"
" is required to floorplan each instance of the design. The Hammer team is"
" actively developing methods of improving the agility of floorplanning "
"for generator-based designs, like those that use Chisel. The libraries we"
" are developing will emit Hammer IR that can be passed directly to the "
"Hammer tool without the need for human intervention. Stay tuned for more "
"information."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:43
msgid ""
"In the meantime, see the `Hammer Documentation <https://hammer-"
"vlsi.readthedocs.io/>`__ for information on the Hammer IR floorplan API. "
"It is possible to write this IR directly, or to generate it using simple "
"python scripts. While we certainly look forward to having a more "
"featureful toolkit, we have built many chips to date in this way."
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:49
msgid "Running the VLSI tool flow"
msgstr ""

#: ../../VLSI/Building-A-Chip.rst:51
msgid ""
"For the full documentation on how to use the VLSI tool flow, see the "
"`Hammer Documentation <https://hammer-vlsi.readthedocs.io/>`__. For an "
"example of how to use the VLSI in the context of Chipyard, see "
":ref:`VLSI/Tutorial:ASAP7 Tutorial`."
msgstr ""

#: ../../VLSI/Hammer.rst:4
msgid "Core Hammer"
msgstr ""

#: ../../VLSI/Hammer.rst:6
msgid ""
"`Hammer <https://github.com/ucb-bar/hammer>`__ is a physical design flow "
"which encourages reusability by partitioning physical design "
"specifications into three distinct concerns: design, CAD tool, and "
"process technology. Hammer wraps around vendor specific technologies and "
"tools to provide a single API to address ASIC design concerns. Hammer "
"allows for reusability in ASIC design while still providing the designers"
" leeway to make their own modifications."
msgstr ""

#: ../../VLSI/Hammer.rst:9
msgid ""
"For more information, read the `Hammer paper "
"<https://people.eecs.berkeley.edu/~edwardw/pubs/hammer-woset-2018.pdf>`__"
" and see the `GitHub repository <https://github.com/ucb-bar/hammer>`__ "
"and associated documentation."
msgstr ""

#: ../../VLSI/Hammer.rst:11
msgid "Hammer implements a VLSI flow using the following high-level constructs:"
msgstr ""

#: ../../VLSI/Hammer.rst:14
msgid "Actions"
msgstr ""

#: ../../VLSI/Hammer.rst:16
msgid ""
"Actions are the top-level tasks Hammer is capable of executing (e.g. "
"synthesis, place-and-route, etc.)"
msgstr ""

#: ../../VLSI/Hammer.rst:19
msgid "Steps"
msgstr ""

#: ../../VLSI/Hammer.rst:21
msgid ""
"Steps are the sub-components of actions that individually addressable in "
"Hammer (e.g. placement in the place-and-route action)."
msgstr ""

#: ../../VLSI/Hammer.rst:24
msgid "Hooks"
msgstr ""

#: ../../VLSI/Hammer.rst:26
msgid ""
"Hooks are modifications to steps or actions that are programmatically "
"defined in a Hammer configuration."
msgstr ""

#: ../../VLSI/Hammer.rst:29
msgid "Configuration (Hammer IR)"
msgstr ""

#: ../../VLSI/Hammer.rst:31
msgid ""
"To configure a Hammer flow, supply a set ``yaml`` or ``json`` "
"configuration files that chooses the tool and technology plugins and "
"versions as well as any design specific configuration options. "
"Collectively, this configuration API is referred to as Hammer IR and can "
"be generated from higher-level abstractions."
msgstr ""

#: ../../VLSI/Hammer.rst:33
msgid ""
"The current set of all available Hammer APIs is codified `here "
"<https://github.com/ucb-bar/hammer/blob/master/src/hammer-"
"vlsi/defaults.yml>`__."
msgstr ""

#: ../../VLSI/Hammer.rst:36
msgid "Tool Plugins"
msgstr ""

#: ../../VLSI/Hammer.rst:38
msgid ""
"Hammer supports separately managed plugins for different CAD tool "
"vendors. You may be able to acquire access to the included Cadence, "
"Synopsys, and Mentor plugins repositories with permission from the "
"respective CAD tool vendor. The types of tools (by Hammer names) "
"supported currently include:"
msgstr ""

#: ../../VLSI/Hammer.rst:41
msgid "synthesis"
msgstr ""

#: ../../VLSI/Hammer.rst:42
msgid "par"
msgstr ""

#: ../../VLSI/Hammer.rst:43
msgid "drc"
msgstr ""

#: ../../VLSI/Hammer.rst:44
msgid "lvs"
msgstr ""

#: ../../VLSI/Hammer.rst:45
msgid "sram_generator"
msgstr ""

#: ../../VLSI/Hammer.rst:46
msgid "sim"
msgstr ""

#: ../../VLSI/Hammer.rst:47
msgid "power"
msgstr ""

#: ../../VLSI/Hammer.rst:48
msgid "pcb"
msgstr ""

#: ../../VLSI/Hammer.rst:50
msgid ""
"Several configuration variables are needed to configure your tool plugin "
"of choice."
msgstr ""

#: ../../VLSI/Hammer.rst:52
msgid ""
"First, select which tool to use for each action by setting "
"``vlsi.core.<tool_type>_tool`` to the name of your tool, e.g. "
"``vlsi.core.par_tool: \"innovus\"``."
msgstr ""

#: ../../VLSI/Hammer.rst:54
msgid ""
"Then, point Hammer to the folder that contains your tool plugin by "
"setting ``vlsi.core.<tool_type>_tool_path``. This directory should "
"include a folder with the name of the tool, which itself includes a "
"python file ``__init__.py`` and a yaml file ``defaults.yml``. Customize "
"the version of the tool by setting ``<tool_type>.<tool_name>.version`` to"
" a tool specific string."
msgstr ""

#: ../../VLSI/Hammer.rst:57
msgid ""
"The ``__init__.py`` file should contain a variable, ``tool``, that points"
" to the class implementing this tool. This class should be a subclass of "
"``Hammer<tool_type>Tool``, which will be a subclass of ``HammerTool``. "
"The class should implement methods for all the tool's steps."
msgstr ""

#: ../../VLSI/Hammer.rst:60
msgid ""
"The ``defaults.yml`` file contains tool-specific configuration variables."
" The defaults may be overridden as necessary."
msgstr ""

#: ../../VLSI/Hammer.rst:63
msgid "Technology Plugins"
msgstr ""

#: ../../VLSI/Hammer.rst:65
msgid ""
"Hammer supports separately managed technology plugins to satisfy NDAs. "
"You may be able to acquire access to certain pre-built technology plugins"
" with permission from the technology vendor. Or, to build your own tech "
"plugin, you need at least a ``<tech_name>.tech.json`` and "
"``defaults.yml``. An ``__init__.py`` is optional if there are any "
"technology-specific methods or hooks to run."
msgstr ""

#: ../../VLSI/Hammer.rst:67
msgid ""
"The `ASAP7 plugin <https://github.com/ucb-bar/hammer/tree/master/src"
"/hammer-vlsi/technology/asap7>`__ is a good starting point for setting up"
" a technology plugin because it is an open-source example that is not "
"suitable for taping out a chip. Refer to Hammer's documentation for the "
"schema and detailed setup instructions."
msgstr ""

#: ../../VLSI/Hammer.rst:69
msgid ""
"Several configuration variables are needed to configure your technology "
"of choice."
msgstr ""

#: ../../VLSI/Hammer.rst:71
msgid ""
"First, choose the technology, e.g. ``vlsi.core.technology: asap7``, then "
"point to the location with the PDK tarball with "
"``technology.<tech_name>.tarball_dir`` or pre-installed directory with "
"``technology.<tech_name>.install_dir`` and (if applicable) the plugin "
"repository with ``vlsi.core.technology_path``."
msgstr ""

#: ../../VLSI/Hammer.rst:73
msgid ""
"Technology-specific options such as supplies, MMMC corners, etc. are "
"defined in their respective ``vlsi.inputs...`` configurations. Options "
"for the most common use case are already defined in the technology's "
"``defaults.yml`` and can be overridden by the user."
msgstr ""

#: ../../VLSI/Tutorial.rst:4
msgid "ASAP7 Tutorial"
msgstr ""

#: ../../VLSI/Tutorial.rst:5
msgid ""
"The ``vlsi`` folder of this repository contains an example Hammer flow "
"with the SHA-3 accelerator and a dummy hard macro. This example tutorial "
"uses the built-in ASAP7 technology plugin and requires access to the "
"included Cadence and Mentor tool plugin submodules. Cadence is necessary "
"for synthesis & place-and-route, while Mentor is needed for DRC & LVS."
msgstr ""

#: ../../VLSI/Tutorial.rst:8
msgid "Project Structure"
msgstr ""

#: ../../VLSI/Tutorial.rst:10
msgid ""
"This example gives a suggested file structure and build system. The "
"``vlsi/`` folder will eventually contain the following files and folders:"
msgstr ""

#: ../../VLSI/Tutorial.rst:12
msgid "Makefile, sim.mk, power.mk"
msgstr ""

#: ../../VLSI/Tutorial.rst:14
msgid ""
"Integration of Hammer's build system into Chipyard and abstracts away "
"some Hammer commands."
msgstr ""

#: ../../VLSI/Tutorial.rst:16
msgid "build"
msgstr ""

#: ../../VLSI/Tutorial.rst:18
msgid "Hammer output directory. Can be changed with the ``OBJ_DIR`` variable."
msgstr ""

#: ../../VLSI/Tutorial.rst:19
msgid ""
"Will contain subdirectories such as ``syn-rundir`` and ``par-rundir`` and"
" the ``inputs.yml`` denoting the top module and input Verilog files."
msgstr ""

#: ../../VLSI/Tutorial.rst:21
msgid "env.yml"
msgstr ""

#: ../../VLSI/Tutorial.rst:23
msgid ""
"A template file for tool environment configuration. Fill in the install "
"and license server paths for your environment."
msgstr ""

#: ../../VLSI/Tutorial.rst:25 ../../VLSI/Tutorial.rst:95
msgid "example-vlsi"
msgstr ""

#: ../../VLSI/Tutorial.rst:27
msgid "Entry point to Hammer. Contains example placeholders for hooks."
msgstr ""

#: ../../VLSI/Tutorial.rst:29
msgid "example-asap7.yml, example-tools.yml"
msgstr ""

#: ../../VLSI/Tutorial.rst:31
msgid "Hammer IR for this tutorial."
msgstr ""

#: ../../VLSI/Tutorial.rst:33
msgid "example-design.yml, example-nangate45.yml, example-tech.yml"
msgstr ""

#: ../../VLSI/Tutorial.rst:35
msgid "Hammer IR not used for this tutorial but provided as templates."
msgstr ""

#: ../../VLSI/Tutorial.rst:37
msgid "generated-src"
msgstr ""

#: ../../VLSI/Tutorial.rst:39
msgid "All of the elaborated Chisel and FIRRTL."
msgstr ""

#: ../../VLSI/Tutorial.rst:41
msgid "hammer, hammer-<vendor>-plugins, hammer-<tech>-plugin"
msgstr ""

#: ../../VLSI/Tutorial.rst:43
msgid "Core, tool, tech repositories."
msgstr ""

#: ../../VLSI/Tutorial.rst:45
msgid "view_gds.py"
msgstr ""

#: ../../VLSI/Tutorial.rst:47
msgid ""
"A convenience script to view a layout using gdspy. Note that this will be"
" very slow for large layouts (e.g. a Rocket core)!"
msgstr ""

#: ../../VLSI/Tutorial.rst:50
msgid "Prerequisites"
msgstr ""

#: ../../VLSI/Tutorial.rst:52
msgid "Python 3.4+"
msgstr ""

#: ../../VLSI/Tutorial.rst:53
msgid "numpy and gdspy packages. gdspy must be version 1.4."
msgstr ""

#: ../../VLSI/Tutorial.rst:54
msgid "Genus, Innovus, and Calibre licenses"
msgstr ""

#: ../../VLSI/Tutorial.rst:55
msgid "For ASAP7 specifically:"
msgstr ""

#: ../../VLSI/Tutorial.rst:57
msgid ""
"Download the `ASAP7 PDK v1p5 <http://asap.asu.edu/asap/>`__ tarball to a "
"directory of choice but do not extract it. The tech plugin is configured "
"to extract the PDK into a cache directory for you. Note: v1p5 of the PDK "
"is not publicly available, and you will need to contact the developers "
"for it. The v1p7 version that is `publicly released <https://github.com"
"/The-OpenROAD-Project/asap7>`__ currently has several critical issues "
"which prevent it from being fully integrated into the Hammer flow."
msgstr ""

#: ../../VLSI/Tutorial.rst:58
msgid ""
"If you have additional ASAP7 hard macros, their LEF & GDS need to be 4x "
"upscaled @ 4000 DBU precision. They may live outside ``extra_libraries`` "
"at your discretion."
msgstr ""

#: ../../VLSI/Tutorial.rst:59
msgid "Innovus version must be >= 15.2 or <= 18.1 (ISRs excluded)."
msgstr ""

#: ../../VLSI/Tutorial.rst:62
msgid "Initial Setup"
msgstr ""

#: ../../VLSI/Tutorial.rst:69
msgid ""
"to pull the Hammer & plugin submodules. Note that for technologies other "
"than ``asap7``, the tech submodule must be added in the ``vlsi`` folder "
"first."
msgstr ""

#: ../../VLSI/Tutorial.rst:71
msgid "Pull the Hammer environment into the shell:"
msgstr ""

#: ../../VLSI/Tutorial.rst:81
msgid ""
"To elaborate the ``TinyRocketConfig`` and set up all prerequisites for "
"the build system to push the design and SRAM macros through the flow:"
msgstr ""

#: ../../VLSI/Tutorial.rst:87
msgid ""
"The ``CONFIG=TinyRocketConfig`` selects the target generator config in "
"the same manner as the rest of the Chipyard framework. This elaborates a "
"stripped-down Rocket Chip in the interest of minimizing tool runtime."
msgstr ""

#: ../../VLSI/Tutorial.rst:89
msgid ""
"For the curious, ``make buildfile`` generates a set of Make targets in "
"``build/hammer.d``. It needs to be re-run if environment variables are "
"changed. It is recommended that you edit these variables directly in the "
"Makefile rather than exporting them to your shell environment."
msgstr ""

#: ../../VLSI/Tutorial.rst:96
msgid ""
"This is the entry script with placeholders for hooks. In the "
"``ExampleDriver`` class, a list of hooks is passed in the "
"``get_extra_par_hooks``. Hooks are additional snippets of python and TCL "
"(via ``x.append()``) to extend the Hammer APIs. Hooks can be inserted "
"using the ``make_pre/post/replacement_hook`` methods as shown in this "
"example. Refer to the Hammer documentation on hooks for a detailed "
"description of how these are injected into the VLSI flow."
msgstr ""

#: ../../VLSI/Tutorial.rst:98
msgid ""
"The ``scale_final_gds`` hook is a particularly powerful hook. It dumps a "
"Python script provided by the ASAP7 tech plugin, an executes it within "
"the Innovus TCL interpreter, and should be inserted after "
"``write_design``. This hook is necessary because the ASAP7 PDK does "
"place-and-route using 4x upscaled LEFs for Innovus licensing reasons, "
"thereby requiring the cells created in the post-P&R GDS to be scaled down"
" by a factor of 4."
msgstr ""

#: ../../VLSI/Tutorial.rst:101
msgid "example.yml"
msgstr ""

#: ../../VLSI/Tutorial.rst:102
msgid ""
"This contains the Hammer configuration for this example project. Example "
"clock constraints, power straps definitions, placement constraints, and "
"pin constraints are given. Additional configuration for the extra "
"libraries and tools are at the bottom."
msgstr ""

#: ../../VLSI/Tutorial.rst:104
msgid ""
"First, set ``technology.asap7.tarball_dir`` to the absolute path to the "
"directory where the downloaded the ASAP7 PDK tarball lives."
msgstr ""

#: ../../VLSI/Tutorial.rst:112
msgid ""
"Post-synthesis logs and collateral are in ``build/syn-rundir``. The raw "
"QoR data is available at ``build/syn-rundir/reports``, and methods to "
"extract this information for design space exploration are a WIP."
msgstr ""

#: ../../VLSI/Tutorial.rst:120
msgid ""
"After completion, the final database can be opened in an interactive "
"Innovus session via ``./build/par-rundir/generated-scripts/open_chip``."
msgstr ""

#: ../../VLSI/Tutorial.rst:122
msgid ""
"Intermediate database are written in ``build/par-rundir`` between each "
"step of the ``par`` action, and can be restored in an interactive Innovus"
" session as desired for debugging purposes."
msgstr ""

#: ../../VLSI/Tutorial.rst:124
msgid ""
"Timing reports are found in ``build/par-rundir/timingReports``. They are "
"gzipped text files."
msgstr ""

#: ../../VLSI/Tutorial.rst:126
msgid ""
"`gdspy` can be used to `view the final layout "
"<https://gdspy.readthedocs.io/en/stable/reference.html?highlight=scale#layoutviewer>`__,"
" but it is somewhat crude and slow (wait a few minutes for it to load):"
msgstr ""

#: ../../VLSI/Tutorial.rst:132
msgid ""
"By default, this script only shows the M2 thru M4 routing. Layers can be "
"toggled in the layout viewer's side pane and ``view_gds.py`` has a "
"mapping of layer numbers to layer names."
msgstr ""

#: ../../VLSI/Tutorial.rst:135
msgid "DRC & LVS"
msgstr ""

#: ../../VLSI/Tutorial.rst:136
msgid "To run DRC & LVS, and view the results in Calibre:"
msgstr ""

#: ../../VLSI/Tutorial.rst:145
msgid ""
"Some DRC errors are expected from this PDK, as explained in the `ASAP7 "
"plugin readme <https://github.com/ucb-bar/hammer/tree/master/src/hammer-"
"vlsi/technology/asap7>`__. Furthermore, the dummy SRAMs that are provided"
" in this tutorial and PDK do not have any geometry inside, so will "
"certainly cause DRC and LVS errors."
msgstr ""

#: ../../VLSI/Tutorial.rst:149
msgid "Simulation"
msgstr ""

#: ../../VLSI/Tutorial.rst:150
msgid ""
"Simulation with VCS is supported, and can be run at the RTL- or gate-"
"level (post-synthesis and P&R). The simulation infrastructure as included"
" here is intended for running RISC-V binaries on a Chipyard config. For "
"example, for an RTL-level simulation:"
msgstr ""

#: ../../VLSI/Tutorial.rst:156
msgid ""
"Post-synthesis and post-P&R simulations use the ``sim-syn`` and ``sim-"
"par`` targets, respectively."
msgstr ""

#: ../../VLSI/Tutorial.rst:158
msgid ""
"There are also ``-debug`` and ``-debug-timing``, which will instruct VCS "
"to write a SAIF + VPD and do timing-annotated simulations, respectively. "
"See the ``sim.mk`` file for all available targets."
msgstr ""

#: ../../VLSI/Tutorial.rst:160
msgid ""
"Note that for the ASAP7 example, gate-level simulations will currently "
"timeout."
msgstr ""

#: ../../VLSI/Tutorial.rst:163
msgid "Power/Rail Analysis"
msgstr ""

#: ../../VLSI/Tutorial.rst:164
msgid "Post-P&R power and rail (IR drop) analysis is supported with Voltus:"
msgstr ""

#: ../../VLSI/Tutorial.rst:170
msgid ""
"If you append the ``BINARY`` variable to the command, it will use the "
"activity file generated from a ``sim-<syn/par>-debug`` run and report "
"dynamic power & IR drop from the toggles encoded in the waveform."
msgstr ""

#: ../../VLSI/Tutorial.rst:172
msgid ""
"Note that for ASAP7, to bypass gate-level simulation, you will need to "
"run the power tool manually (see the generated commands in the generated "
"``hammer.d`` buildfile). Static and active (vectorless) power & IR drop "
"will be reported."
msgstr ""

#: ../../VLSI/index.rst:7
msgid "VLSI Flow:"
msgstr ""

#: ../../VLSI/index.rst:2
msgid "VLSI Flow"
msgstr ""

#: ../../VLSI/index.rst:4
msgid ""
"The Chipyard framework aims to provide wrappers for a general VLSI flow. "
"In particular, we aim to support the Hammer physical design generator "
"flow."
msgstr ""

