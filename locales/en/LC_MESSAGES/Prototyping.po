# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Berkeley Architecture Research
# This file is distributed under the same license as the Chipyard package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Chipyard \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-28 13:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../Prototyping/Arty.rst:2
msgid "Running a Design on Arty"
msgstr ""

#: ../../Prototyping/Arty.rst:5
msgid "Basic Arty Design"
msgstr ""

#: ../../Prototyping/Arty.rst:7
msgid ""
"The default Xilinx Arty 35T harness is setup to have JTAG available over "
"the board's PMOD pins, and UART available over its FTDI serial USB "
"adapter. The pin mappings for JTAG signals are identical to those "
"described in the `SiFive Freedom E310 Arty 35T Getting Started Guide "
"<https://static.dev.sifive.com/SiFive-E310-arty-"
"gettingstarted-v1.0.6.pdf>`__. The JTAG interface allows a user to "
"connect to the core via OpenOCD, run bare-metal applications, and debug "
"these applications with gdb. UART allows a user to communicate with the "
"core over a USB connection and serial console running on a PC. To extend "
"this design, a user may create their own Chipyard configuration and add "
"the ``WithArtyTweaks`` located in "
"``fpga/src/main/scala/arty/Configs.scala``. Adding this config. fragment "
"will enable and connect the JTAG and UART interfaces to your Chipyard "
"design."
msgstr ""

#: ../../Prototyping/Arty.rst:17
msgid ""
"Future peripherals to be supported include the Arty 35T SPI Flash EEPROM,"
" and I2C/PWM/SPI over the Arty 35T GPIO pins. These peripherals are "
"available as part of sifive-blocks."
msgstr ""

#: ../../Prototyping/Arty.rst:20
msgid ""
"Brief Implementation Description and Guidance for Adding/Changing Xilinx "
"Collateral"
msgstr ""

#: ../../Prototyping/Arty.rst:22
msgid ""
"Like the VCU118, the basis for the Arty 35T design is the creation of a "
"special test harness that connects the external IO (which exist as Xilinx"
" IP blackboxes) to the Chipyard design. This is done with the "
"``ArtyTestHarness`` in the basic default Arty 35T target. However, unlike"
" the ``VCU118TestHarness``, the ``ArtyTestHarness`` uses no ``Overlays``,"
" and instead directly connects chip top IO to the ports of the external "
"IO blackboxes, using functions such as ``IOBUF`` provided by ``fpga-"
"shells``. Unlike the VCU118 and other more complicated test harnesses, "
"the Arty 35T Vivado collateral is not generated by ``Overlays``, but "
"rather are a static collection of ``create_ip`` and ``set_properties`` "
"statements located in the files within ``fpga/fpga-"
"shells/xilinx/arty/tcl`` and ``fpga/fpga-"
"shells/xilinx/arty/constraints``. If the user wishes to re-map FPGA "
"package pins to different harness-level IO, this may be changed within "
"``fpga/fpga-shells/xilinx/arty/constraints/arty-master.xdc``. The "
"addition of new Xilinx IP blocks may be done in ``fpga-"
"shells/xilinx/arty/tcl/ip.tcl``, mapped to harness-level IOs in ``arty-"
"master.xdc``, and wired through from the test harness to the chip top "
"using ``HarnessBinders`` and ``IOBinders``. Examples of a simple "
"``IOBinder`` and ``HarnessBinder`` for routing signals (in this case the "
"debug and JTAG resets) from the core to the test harness are the "
"``WithResetPassthrough`` and ``WithArtyResetHarnessBinder``."
msgstr ""

#: ../../Prototyping/General.rst:2
msgid "General Setup and Usage"
msgstr ""

#: ../../Prototyping/General.rst:5
msgid "Sources and Submodule Setup"
msgstr ""

#: ../../Prototyping/General.rst:7
msgid ""
"All FPGA prototyping-related collateral and sources are located in the "
"``fpga`` top-level Chipyard directory. This includes the ``fpga-shells`` "
"submodule and the ``src`` directory that hold both Scala, TCL and other "
"collateral. However, the ``fpga-shells`` submodule repository is not "
"initialized by default. To initialize the ``fpga-shells`` submodule "
"repository, run the included initialization script from the Chipyard top-"
"level directory:"
msgstr ""

#: ../../Prototyping/General.rst:18
msgid "Generating a Bitstream"
msgstr ""

#: ../../Prototyping/General.rst:20
msgid ""
"Generating a bitstream for any FPGA target using Vivado is similar to "
"building RTL for a software RTL simulation. Similar to a software RTL "
"simulation (:ref:`Simulation/Software-RTL-Simulation:Simulating A Custom "
"Project`), you can run the following command in the ``fpga`` directory to"
" build a bitstream using Vivado:"
msgstr ""

#: ../../Prototyping/General.rst:31
msgid ""
"The ``SUB_PROJECT`` make variable is a way to meta make variable that "
"sets all of the other make variables to a specific default. For example:"
msgstr ""

#: ../../Prototyping/General.rst:42
msgid ""
"Some ``SUB_PROJECT`` defaults are already defined for use, including "
"``vcu118`` and ``arty``. These default ``SUB_PROJECT``'s setup the "
"necessary test harnesses, packages, and more for the Chipyard make "
"system. Like a software RTL simulation make invocation, all of the make "
"variables can be overridden with user specific values (ex. include the "
"``SUB_PROJECT`` with a ``CONFIG`` and ``CONFIG_PACKAGE`` override). In "
"most cases, you will just need to run a command with a ``SUB_PROJECT`` "
"and an overridden ``CONFIG`` to point to. For example, building the BOOM "
"configuration on the VCU118:"
msgstr ""

#: ../../Prototyping/General.rst:52
msgid ""
"That command will build the RTL and generate a bitstream using Vivado. "
"The generated bitstream will be located in your designs specific build "
"folder (``generated-src/<LONG_NAME>/obj``). However, like a software RTL "
"simulation, you can also run the intermediate make steps to just generate"
" Verilog or FIRRTL."
msgstr ""

#: ../../Prototyping/General.rst:57
msgid "Debugging with ILAs on Supported FPGAs"
msgstr ""

#: ../../Prototyping/General.rst:59
msgid ""
"ILA (integrated logic analyzers) can be added to certain designs for "
"debugging relevant signals. First, open up the post synthesis checkpoint "
"located in the build directory for your design in Vivado (it should be "
"labeled ``post_synth.dcp``). Then using Vivado, add ILAs (and other "
"debugging tools) for your design (search online for more information on "
"how to add an ILA). This can be done by modifying the post synthesis "
"checkpoint, saving it, and running ``make ... debug-bitstream``. This "
"will create a new bitstream called ``top.bit`` in a folder named "
"``generated-src/<LONG_NAME>/debug_obj/``. For example, running the "
"bitstream build for an added ILA for a BOOM config.:"
msgstr ""

#: ../../Prototyping/General.rst:70
msgid ""
"For more extensive debugging tools for FPGA simulations including printf "
"synthesis, assert synthesis, instruction traces, ILAs, out-of-band "
"profiling, co-simulation, and more, please refer to the :ref:`Simulation"
"/FPGA-Accelerated-Simulation:FireSim` platform."
msgstr ""

#: ../../Prototyping/VCU118.rst:2
msgid "Running a Design on VCU118"
msgstr ""

#: ../../Prototyping/VCU118.rst:5
msgid "Basic VCU118 Design"
msgstr ""

#: ../../Prototyping/VCU118.rst:7
msgid ""
"The default Xilinx VCU118 harness is setup to have UART, a SPI SDCard, "
"and DDR backing memory. This allows it to run RISC-V Linux from an SDCard"
" while piping the terminal over UART to the host machine (the machine "
"connected to the VCU118). To extend this design, you can create your own "
"Chipyard configuration and add the ``WithVCU118Tweaks`` located in "
"``fpga/src/main/scala/vcu118/Configs.scala``. Adding this config fragment"
" will enable and connect the UART, SPI SDCard, and DDR backing memory to "
"your Chipyard design/config."
msgstr ""

#: ../../Prototyping/VCU118.rst:18
msgid "Brief Implementation Description + More Complicated Designs"
msgstr ""

#: ../../Prototyping/VCU118.rst:20
msgid ""
"The basis for a VCU118 design revolves around creating a special test "
"harness to connect the external IOs to your Chipyard design. This is done"
" with the ``VCU118TestHarness`` in the basic default VCU118 FPGA target. "
"The ``VCU118TestHarness`` (located in "
"``fpga/src/main/scala/vcu118/TestHarness.scala``) uses ``Overlays`` that "
"connect to the VCU118 external IOs. Generally, the ``Overlays`` take an "
"IO from the ``ChipTop`` (labeled as ``topDesign`` in the file) when "
"\"placed\" and connect it to the external IO and generate necessary "
"Vivado collateral. For example, the following shows a UART ``Overlay`` "
"being \"placed\" into the design with a IO input called ``io_uart_bb``."
msgstr ""

#: ../../Prototyping/VCU118.rst:31
msgid ""
"Here the ``UARTOverlayKey`` is referenced and used to \"place\" the "
"necessary connections (and collateral) to connect to the UART. The "
"``UARTDesignInput`` is used to pass in the UART IO from the "
"``ChipTop``/``topDesign`` to the ``Overlay``. Note that the "
"``BundleBridgeSource`` can be viewed as a glorified wire (that is defined"
" in the ``LazyModule`` scope). This pattern is similar for all other "
"``Overlays`` in the test harness. They must be \"placed\" and given a set"
" of inputs (IOs, parameters). The main exception to this pattern is the "
"``Overlay`` used to generate the clock(s) for the FPGA."
msgstr ""

#: ../../Prototyping/VCU118.rst:43
msgid ""
"Without going into too much detail, the clocks overlay is placed in the "
"harness and a PLL node (``harnessSysPLL``) generates the necessary clocks"
" specified by ``ClockSinkNodes``. For ease of use, you can change the "
"``FPGAFrequencyKey`` to change the default clock frequency of the FPGA "
"design."
msgstr ""

#: ../../Prototyping/VCU118.rst:46
msgid ""
"After the harness is created, the ``BundleBridgeSource``'s must be "
"connected to the ``ChipTop`` IOs. This is done with harness binders and "
"io binders (see ``fpga/src/main/scala/vcu118/HarnessBinders.scala`` and "
"``fpga/src/main/scala/vcu118/IOBinders.scala``). For more information on "
"harness binders and io binders, refer to "
":ref:`Customization/IOBinders:IOBinders and HarnessBinders`."
msgstr ""

#: ../../Prototyping/VCU118.rst:51
msgid "Introduction to the Bringup Design"
msgstr ""

#: ../../Prototyping/VCU118.rst:53
msgid ""
"An example of a more complicated design used for Chipyard test chips can "
"be viewed in ``fpga/src/main/scala/vcu118/bringup/``. This example "
"extends the default test harness and creates new ``Overlays`` to connect "
"to a DUT (connected to the FMC port). Extensions include another UART "
"(connected over FMC), I2C (connected over FMC), miscellaneous GPIOS (can "
"be connected to anything), and a TSI Host Widget. The TSI Host Widget is "
"used to interact with the DUT from the prototype over a SerDes link "
"(sometimes called the Low BandWidth InterFace - LBWIF) and provide access"
" to a channel of the FPGA's DRAM."
msgstr ""

#: ../../Prototyping/VCU118.rst:58
msgid ""
"Remember that since whenever a new test harness is created (or the config"
" changes, or the config packages changes, or...), you need to modify the "
"make invocation. For example, ``make SUB_PROJECT=vcu118 "
"CONFIG=MyNewVCU118Config CONFIG_PACKAGE=this.is.my.scala.package "
"bitstream``. See :ref:`Prototyping/General:Generating a Bitstream` for "
"information on the various make variables."
msgstr ""

#: ../../Prototyping/VCU118.rst:63
msgid "Running Linux on VCU118 Designs"
msgstr ""

#: ../../Prototyping/VCU118.rst:65
msgid ""
"As mentioned above, the default VCU118 harness is setup with a UART and a"
" SPI SDCard. These are utilized to both interact with the DUT (with the "
"UART) and load in Linux (with the SDCard). The following steps describe "
"how to build and run buildroot Linux on the prototype platform."
msgstr ""

#: ../../Prototyping/VCU118.rst:70
msgid "Building Linux with FireMarshal"
msgstr ""

#: ../../Prototyping/VCU118.rst:72
msgid ""
"Since the prototype currently does not have a block device setup for it, "
"we build Linux with the rootfs built into the binary (otherwise known as "
"\"initramfs\" or \"nodisk\" version of Linux). To make building this type"
" of Linux binary easy, we will use the FireMarshal platform (see :ref"
":`fire-marshal` for more information)."
msgstr ""

#: ../../Prototyping/VCU118.rst:75
msgid "Setup FireMarshal (see :ref:`fire-marshal` on the initial setup)."
msgstr ""

#: ../../Prototyping/VCU118.rst:76
msgid ""
"By default, FireMarshal is setup to work with FireSim. Instead, we want "
"to target the prototype platform. This is done by switching the "
"FireMarshal \"board\" from \"firechip\" to \"prototype\" using ``marshal-"
"config.yaml``:"
msgstr ""

#: ../../Prototyping/VCU118.rst:85
msgid ""
"Refer to the FireMarshal docs on more ways to set the board differently "
"through environment variables and more."
msgstr ""

#: ../../Prototyping/VCU118.rst:87
msgid ""
"Next, build the workload (a.k.a buildroot Linux) in FireMarshal with the "
"``nodisk`` option flag. For the rest of these steps, we will assume you "
"are using the base ``br-base.json`` workload. This workload has basic "
"support for GPIO and SPI drivers (in addition to the default UART driver)"
" but you can build off it in different workloads (refer to FireMarshal "
"docs on workload inheritance)."
msgstr ""

#: ../../Prototyping/VCU118.rst:95
msgid ""
"Using the \"board\" FireMarshal functionality allows any child workload "
"depending on the ``br-base.json`` workload specification to target a "
"\"prototype\" platform rather than FireChip platform. Thus, you can re-"
"use existing workloads that depend on ``br-base.json`` on the prototype "
"platform by just changing the \"board\"!"
msgstr ""

#: ../../Prototyping/VCU118.rst:98
msgid ""
"The last step to generate the proper binary is to flatten it. This is "
"done by using FireMarshal's ``install`` feature which will produce a "
"``*-flat`` binary in the ``$PATH_TO_FIREMARSHAL/images`` directory (in "
"our case ``br-base-bin-nodisk-flat``) from the previously built Linux "
"binary (``br-base-bin-nodisk``)."
msgstr ""

#: ../../Prototyping/VCU118.rst:106
msgid "Setting up the SDCard"
msgstr ""

#: ../../Prototyping/VCU118.rst:108
msgid ""
"These instructions assume that you have a spare uSDCard that can be "
"loaded with Linux and other files using two partitions. The 1st partition"
" will be used to store the Linux binary (created with FireMarshal or "
"other means) while the 2nd partition will store a file system that can be"
" accessed from the DUT. Additionally, these instructions assume you are "
"using Linux with ``sudo`` privileges and ``gdisk``, but you can follow a "
"similar set of steps on Mac (using ``gpt`` or another similar program)."
msgstr ""

#: ../../Prototyping/VCU118.rst:112
msgid ""
"Wipe the GPT on the card using ``gdisk``. Use the `z` command to zap "
"everything from the expert menu (opened with 'x', closed with 'm'). For "
"rest of these instructions, we assume the SDCard path is ``/dev/sdc`` "
"(replace this with the path to your SDCard)."
msgstr ""

#: ../../Prototyping/VCU118.rst:120
msgid "Create the new GPT with `o`. Click yes on all the prompts."
msgstr ""

#: ../../Prototyping/VCU118.rst:123
msgid ""
"The VCU118 bootrom assumes that the Linux binary to load into memory will"
" be located on sector 34 of the SDCard. Change the default partition "
"alignment to `1` so you can write to sector `34`. Do this with the `l` "
"command from the expert menu (opened with 'x', closed with 'm')."
msgstr ""

#: ../../Prototyping/VCU118.rst:127
msgid ""
"Create a 512MiB partition to store the Linux binary (this can be smaller "
"but it must be larger than the size of the Linux binary). Use `n`, "
"partion number 1 and select sector 34, with size `+1048576` "
"(corresponding to 512MiB). For the type, search for the `apfs` type and "
"use the hex number given."
msgstr ""

#: ../../Prototyping/VCU118.rst:131
msgid ""
"Create a second partition to store any other files with the rest of the "
"SDCard. Use `n` and use the defaults for partition number, starting "
"sector and overall size (expand the 2nd partition to the rest of the "
"SDCard space). For the type, search for the `hfs` and use the hex number "
"given."
msgstr ""

#: ../../Prototyping/VCU118.rst:135
msgid "Write the changes using `w`."
msgstr ""

#: ../../Prototyping/VCU118.rst:137
msgid ""
"Setup the filesystem on the 2nd partition. Note that the ``/dev/sdc2`` "
"points to the 2nd partition. Use the following command:"
msgstr ""

#: ../../Prototyping/VCU118.rst:146
msgid "Transfer and Run Linux from the SDCard"
msgstr ""

#: ../../Prototyping/VCU118.rst:148
msgid ""
"After you have a Linux boot binary and the SDCard is setup properly (1st "
"partition at sector 34), you can transfer the binary to the 1st SDCard "
"partition. In this example, we generated a ``br-base-bin-nodisk-flat`` "
"from FireMarshal and we will load it using ``dd``. Note that ``sdc1`` "
"points to the 1st partition (remember to change the ``sdc`` to your own "
"SDCard path)."
msgstr ""

#: ../../Prototyping/VCU118.rst:156
msgid "If you want to add files to the 2nd partition, you can also do this now."
msgstr ""

#: ../../Prototyping/VCU118.rst:158
msgid ""
"After loading the SDCard with Linux and potentially other files, you can "
"program the FPGA and plug in the SDCard. To interact with Linux via the "
"UART console, you can connect to the serial port (in this case called "
"``ttyUSB1``) using something like ``screen``:"
msgstr ""

#: ../../Prototyping/VCU118.rst:165
msgid ""
"Once connected, you should see the binary being loaded as well as Linux "
"output (in some cases you might need to reset the DUT). Sign in as 'root'"
" with password 'fpga'."
msgstr ""

#: ../../Prototyping/index.rst:10
msgid "Prototyping Flow:"
msgstr ""

#: ../../Prototyping/index.rst:2
msgid "Prototyping Flow"
msgstr ""

#: ../../Prototyping/index.rst:4
msgid ""
"Chipyard supports FPGA prototyping for local FPGAs supported by `fpga-"
"shells <https://github.com/sifive/fpga-shells>`__. This includes popular "
"FPGAs such as the Xilinx VCU118 and the Xilinx Arty 35T board."
msgstr ""

#: ../../Prototyping/index.rst:7
msgid ""
"While ``fpga-shells`` provides harnesses for other FPGA development "
"boards such as the Xilinx VC707 and some MicroSemi PolarFire, only "
"harnesses for the Xilinx VCU118 and Xilinx Arty 35T boards are currently "
"supported in Chipyard. However, the VCU118 and Arty 35T examples "
"demonstrate how a user may implement support for other harnesses provided"
" by fpga-shells."
msgstr ""

